# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from miro2_msg/sensors_package.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import geometry_msgs.msg
import sensor_msgs.msg
import nav_msgs.msg
import std_msgs.msg

class sensors_package(genpy.Message):
  _md5sum = "429d8257e8e981414c3f64c0a1074b4d"
  _type = "miro2_msg/sensors_package"
  _has_header = True #flag to mark the presence of a Header object
  _full_text = """#	@section COPYRIGHT
#	Copyright (C) 2019 Consequential Robotics Ltd
#	
#	@section AUTHOR
#	Consequential Robotics http://consequentialrobotics.com
#	
#	@section LICENSE
#	For a full copy of the license agreement, and a complete
#	definition of "The Software", see LICENSE in the MDK root
#	directory.
#	
#	Subject to the terms of this Agreement, Consequential
#	Robotics grants to you a limited, non-exclusive, non-
#	transferable license, without right to sub-license, to use
#	"The Software" in accordance with this Agreement and any
#	other written agreement with Consequential Robotics.
#	Consequential Robotics does not transfer the title of "The
#	Software" to you; the license granted to you is not a sale.
#	This agreement is a binding legal agreement between
#	Consequential Robotics and the purchasers or users of "The
#	Software".
#	
#	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
#	KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
#	WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
#	PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
#	OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
#	OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
#	OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
#	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#	
#
#	This message packages all the messages in /sensors into one
#	container so that a subscriber can receive them succinctly,
#	and in synchrony.



#### HEADER

# standard header
std_msgs/Header header



#### CONTENT

sensor_msgs/BatteryState battery
std_msgs/Float32MultiArray cliff
std_msgs/UInt16 dip
std_msgs/UInt32 flags
sensor_msgs/Imu imu_head
sensor_msgs/Imu imu_body
sensor_msgs/JointState kinematic_joints
std_msgs/Float32MultiArray light
nav_msgs/Odometry odom
sensor_msgs/Range sonar
std_msgs/UInt16MultiArray stream
std_msgs/UInt16 touch_body
std_msgs/UInt16 touch_head
std_msgs/Float32MultiArray wheel_speed_cmd
std_msgs/Float32MultiArray wheel_speed_back_emf
std_msgs/Float32MultiArray wheel_speed_opto
std_msgs/Float32MultiArray wheel_effort_pwm

# available only in the simulator
geometry_msgs/Pose2D body_pose





================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id

================================================================================
MSG: sensor_msgs/BatteryState

# Constants are chosen to match the enums in the linux kernel
# defined in include/linux/power_supply.h as of version 3.7
# The one difference is for style reasons the constants are
# all uppercase not mixed case.

# Power supply status constants
uint8 POWER_SUPPLY_STATUS_UNKNOWN = 0
uint8 POWER_SUPPLY_STATUS_CHARGING = 1
uint8 POWER_SUPPLY_STATUS_DISCHARGING = 2
uint8 POWER_SUPPLY_STATUS_NOT_CHARGING = 3
uint8 POWER_SUPPLY_STATUS_FULL = 4

# Power supply health constants
uint8 POWER_SUPPLY_HEALTH_UNKNOWN = 0
uint8 POWER_SUPPLY_HEALTH_GOOD = 1
uint8 POWER_SUPPLY_HEALTH_OVERHEAT = 2
uint8 POWER_SUPPLY_HEALTH_DEAD = 3
uint8 POWER_SUPPLY_HEALTH_OVERVOLTAGE = 4
uint8 POWER_SUPPLY_HEALTH_UNSPEC_FAILURE = 5
uint8 POWER_SUPPLY_HEALTH_COLD = 6
uint8 POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE = 7
uint8 POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE = 8

# Power supply technology (chemistry) constants
uint8 POWER_SUPPLY_TECHNOLOGY_UNKNOWN = 0
uint8 POWER_SUPPLY_TECHNOLOGY_NIMH = 1
uint8 POWER_SUPPLY_TECHNOLOGY_LION = 2
uint8 POWER_SUPPLY_TECHNOLOGY_LIPO = 3
uint8 POWER_SUPPLY_TECHNOLOGY_LIFE = 4
uint8 POWER_SUPPLY_TECHNOLOGY_NICD = 5
uint8 POWER_SUPPLY_TECHNOLOGY_LIMN = 6

Header  header
float32 voltage          # Voltage in Volts (Mandatory)
float32 current          # Negative when discharging (A)  (If unmeasured NaN)
float32 charge           # Current charge in Ah  (If unmeasured NaN)
float32 capacity         # Capacity in Ah (last full capacity)  (If unmeasured NaN)
float32 design_capacity  # Capacity in Ah (design capacity)  (If unmeasured NaN)
float32 percentage       # Charge percentage on 0 to 1 range  (If unmeasured NaN)
uint8   power_supply_status     # The charging status as reported. Values defined above
uint8   power_supply_health     # The battery health metric. Values defined above
uint8   power_supply_technology # The battery chemistry. Values defined above
bool    present          # True if the battery is present

float32[] cell_voltage   # An array of individual cell voltages for each cell in the pack
                         # If individual voltages unknown but number of cells known set each to NaN
string location          # The location into which the battery is inserted. (slot number or plug)
string serial_number     # The best approximation of the battery serial number

================================================================================
MSG: std_msgs/Float32MultiArray
# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
float32[]         data          # array of data


================================================================================
MSG: std_msgs/MultiArrayLayout
# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding elements at front of data

# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
# 
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.

================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/UInt16
uint16 data

================================================================================
MSG: std_msgs/UInt32
uint32 data
================================================================================
MSG: sensor_msgs/Imu
# This is a message to hold data from an IMU (Inertial Measurement Unit)
#
# Accelerations should be in m/s^2 (not in g's), and rotational velocity should be in rad/sec
#
# If the covariance of the measurement is known, it should be filled in (if all you know is the 
# variance of each measurement, e.g. from the datasheet, just put those along the diagonal)
# A covariance matrix of all zeros will be interpreted as "covariance unknown", and to use the
# data a covariance will have to be assumed or gotten from some other source
#
# If you have no estimate for one of the data elements (e.g. your IMU doesn't produce an orientation 
# estimate), please set element 0 of the associated covariance matrix to -1
# If you are interpreting this message, please check for a value of -1 in the first element of each 
# covariance matrix, and disregard the associated estimate.

Header header

geometry_msgs/Quaternion orientation
float64[9] orientation_covariance # Row major about x, y, z axes

geometry_msgs/Vector3 angular_velocity
float64[9] angular_velocity_covariance # Row major about x, y, z axes

geometry_msgs/Vector3 linear_acceleration
float64[9] linear_acceleration_covariance # Row major x, y z 

================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: sensor_msgs/JointState
# This is a message that holds data to describe the state of a set of torque controlled joints. 
#
# The state of each joint (revolute or prismatic) is defined by:
#  * the position of the joint (rad or m),
#  * the velocity of the joint (rad/s or m/s) and 
#  * the effort that is applied in the joint (Nm or N).
#
# Each joint is uniquely identified by its name
# The header specifies the time at which the joint states were recorded. All the joint states
# in one message have to be recorded at the same time.
#
# This message consists of a multiple arrays, one for each part of the joint state. 
# The goal is to make each of the fields optional. When e.g. your joints have no
# effort associated with them, you can leave the effort array empty. 
#
# All arrays in this message should have the same size, or be empty.
# This is the only way to uniquely associate the joint name with the correct
# states.


Header header

string[] name
float64[] position
float64[] velocity
float64[] effort

================================================================================
MSG: nav_msgs/Odometry
# This represents an estimate of a position and velocity in free space.  
# The pose in this message should be specified in the coordinate frame given by header.frame_id.
# The twist in this message should be specified in the coordinate frame given by the child_frame_id
Header header
string child_frame_id
geometry_msgs/PoseWithCovariance pose
geometry_msgs/TwistWithCovariance twist

================================================================================
MSG: geometry_msgs/PoseWithCovariance
# This represents a pose in free space with uncertainty.

Pose pose

# Row-major representation of the 6x6 covariance matrix
# The orientation parameters use a fixed-axis representation.
# In order, the parameters are:
# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
float64[36] covariance

================================================================================
MSG: geometry_msgs/Pose
# A representation of pose in free space, composed of position and orientation. 
Point position
Quaternion orientation

================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z

================================================================================
MSG: geometry_msgs/TwistWithCovariance
# This expresses velocity in free space with uncertainty.

Twist twist

# Row-major representation of the 6x6 covariance matrix
# The orientation parameters use a fixed-axis representation.
# In order, the parameters are:
# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
float64[36] covariance

================================================================================
MSG: geometry_msgs/Twist
# This expresses velocity in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular

================================================================================
MSG: sensor_msgs/Range
# Single range reading from an active ranger that emits energy and reports
# one range reading that is valid along an arc at the distance measured. 
# This message is  not appropriate for laser scanners. See the LaserScan
# message if you are working with a laser scanner.

# This message also can represent a fixed-distance (binary) ranger.  This
# sensor will have min_range===max_range===distance of detection.
# These sensors follow REP 117 and will output -Inf if the object is detected
# and +Inf if the object is outside of the detection range.

Header header           # timestamp in the header is the time the ranger
                        # returned the distance reading

# Radiation type enums
# If you want a value added to this list, send an email to the ros-users list
uint8 ULTRASOUND=0
uint8 INFRARED=1

uint8 radiation_type    # the type of radiation used by the sensor
                        # (sound, IR, etc) [enum]

float32 field_of_view   # the size of the arc that the distance reading is
                        # valid for [rad]
                        # the object causing the range reading may have
                        # been anywhere within -field_of_view/2 and
                        # field_of_view/2 at the measured range. 
                        # 0 angle corresponds to the x-axis of the sensor.

float32 min_range       # minimum range value [m]
float32 max_range       # maximum range value [m]
                        # Fixed distance rangers require min_range==max_range

float32 range           # range data [m]
                        # (Note: values < range_min or > range_max
                        # should be discarded)
                        # Fixed distance rangers only output -Inf or +Inf.
                        # -Inf represents a detection within fixed distance.
                        # (Detection too close to the sensor to quantify)
                        # +Inf represents no detection within the fixed distance.
                        # (Object out of range)
================================================================================
MSG: std_msgs/UInt16MultiArray
# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
uint16[]            data        # array of data


================================================================================
MSG: geometry_msgs/Pose2D
# Deprecated
# Please use the full 3D pose.

# In general our recommendation is to use a full 3D representation of everything and for 2D specific applications make the appropriate projections into the plane for their calculations but optimally will preserve the 3D information during processing.

# If we have parallel copies of 2D datatypes every UI and other pipeline will end up needing to have dual interfaces to plot everything. And you will end up with not being able to use 3D tools for 2D use cases even if they're completely valid, as you'd have to reimplement it with different inputs and outputs. It's not particularly hard to plot the 2D pose or compute the yaw error for the Pose message and there are already tools and libraries that can do this for you.


# This expresses a position and orientation on a 2D manifold.

float64 x
float64 y
float64 theta
"""
  __slots__ = ['header','battery','cliff','dip','flags','imu_head','imu_body','kinematic_joints','light','odom','sonar','stream','touch_body','touch_head','wheel_speed_cmd','wheel_speed_back_emf','wheel_speed_opto','wheel_effort_pwm','body_pose']
  _slot_types = ['std_msgs/Header','sensor_msgs/BatteryState','std_msgs/Float32MultiArray','std_msgs/UInt16','std_msgs/UInt32','sensor_msgs/Imu','sensor_msgs/Imu','sensor_msgs/JointState','std_msgs/Float32MultiArray','nav_msgs/Odometry','sensor_msgs/Range','std_msgs/UInt16MultiArray','std_msgs/UInt16','std_msgs/UInt16','std_msgs/Float32MultiArray','std_msgs/Float32MultiArray','std_msgs/Float32MultiArray','std_msgs/Float32MultiArray','geometry_msgs/Pose2D']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,battery,cliff,dip,flags,imu_head,imu_body,kinematic_joints,light,odom,sonar,stream,touch_body,touch_head,wheel_speed_cmd,wheel_speed_back_emf,wheel_speed_opto,wheel_effort_pwm,body_pose

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(sensors_package, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.battery is None:
        self.battery = sensor_msgs.msg.BatteryState()
      if self.cliff is None:
        self.cliff = std_msgs.msg.Float32MultiArray()
      if self.dip is None:
        self.dip = std_msgs.msg.UInt16()
      if self.flags is None:
        self.flags = std_msgs.msg.UInt32()
      if self.imu_head is None:
        self.imu_head = sensor_msgs.msg.Imu()
      if self.imu_body is None:
        self.imu_body = sensor_msgs.msg.Imu()
      if self.kinematic_joints is None:
        self.kinematic_joints = sensor_msgs.msg.JointState()
      if self.light is None:
        self.light = std_msgs.msg.Float32MultiArray()
      if self.odom is None:
        self.odom = nav_msgs.msg.Odometry()
      if self.sonar is None:
        self.sonar = sensor_msgs.msg.Range()
      if self.stream is None:
        self.stream = std_msgs.msg.UInt16MultiArray()
      if self.touch_body is None:
        self.touch_body = std_msgs.msg.UInt16()
      if self.touch_head is None:
        self.touch_head = std_msgs.msg.UInt16()
      if self.wheel_speed_cmd is None:
        self.wheel_speed_cmd = std_msgs.msg.Float32MultiArray()
      if self.wheel_speed_back_emf is None:
        self.wheel_speed_back_emf = std_msgs.msg.Float32MultiArray()
      if self.wheel_speed_opto is None:
        self.wheel_speed_opto = std_msgs.msg.Float32MultiArray()
      if self.wheel_effort_pwm is None:
        self.wheel_effort_pwm = std_msgs.msg.Float32MultiArray()
      if self.body_pose is None:
        self.body_pose = geometry_msgs.msg.Pose2D()
    else:
      self.header = std_msgs.msg.Header()
      self.battery = sensor_msgs.msg.BatteryState()
      self.cliff = std_msgs.msg.Float32MultiArray()
      self.dip = std_msgs.msg.UInt16()
      self.flags = std_msgs.msg.UInt32()
      self.imu_head = sensor_msgs.msg.Imu()
      self.imu_body = sensor_msgs.msg.Imu()
      self.kinematic_joints = sensor_msgs.msg.JointState()
      self.light = std_msgs.msg.Float32MultiArray()
      self.odom = nav_msgs.msg.Odometry()
      self.sonar = sensor_msgs.msg.Range()
      self.stream = std_msgs.msg.UInt16MultiArray()
      self.touch_body = std_msgs.msg.UInt16()
      self.touch_head = std_msgs.msg.UInt16()
      self.wheel_speed_cmd = std_msgs.msg.Float32MultiArray()
      self.wheel_speed_back_emf = std_msgs.msg.Float32MultiArray()
      self.wheel_speed_opto = std_msgs.msg.Float32MultiArray()
      self.wheel_effort_pwm = std_msgs.msg.Float32MultiArray()
      self.body_pose = geometry_msgs.msg.Pose2D()

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_3I().pack(_x.battery.header.seq, _x.battery.header.stamp.secs, _x.battery.header.stamp.nsecs))
      _x = self.battery.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_6f4B().pack(_x.battery.voltage, _x.battery.current, _x.battery.charge, _x.battery.capacity, _x.battery.design_capacity, _x.battery.percentage, _x.battery.power_supply_status, _x.battery.power_supply_health, _x.battery.power_supply_technology, _x.battery.present))
      length = len(self.battery.cell_voltage)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.pack(pattern, *self.battery.cell_voltage))
      _x = self.battery.location
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.battery.serial_number
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.cliff.layout.dim)
      buff.write(_struct_I.pack(length))
      for val1 in self.cliff.layout.dim:
        _x = val1.label
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.size, _x.stride))
      buff.write(_get_struct_I().pack(self.cliff.layout.data_offset))
      length = len(self.cliff.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.pack(pattern, *self.cliff.data))
      _x = self
      buff.write(_get_struct_H4I().pack(_x.dip.data, _x.flags.data, _x.imu_head.header.seq, _x.imu_head.header.stamp.secs, _x.imu_head.header.stamp.nsecs))
      _x = self.imu_head.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_4d().pack(_x.imu_head.orientation.x, _x.imu_head.orientation.y, _x.imu_head.orientation.z, _x.imu_head.orientation.w))
      buff.write(_get_struct_9d().pack(*self.imu_head.orientation_covariance))
      _x = self
      buff.write(_get_struct_3d().pack(_x.imu_head.angular_velocity.x, _x.imu_head.angular_velocity.y, _x.imu_head.angular_velocity.z))
      buff.write(_get_struct_9d().pack(*self.imu_head.angular_velocity_covariance))
      _x = self
      buff.write(_get_struct_3d().pack(_x.imu_head.linear_acceleration.x, _x.imu_head.linear_acceleration.y, _x.imu_head.linear_acceleration.z))
      buff.write(_get_struct_9d().pack(*self.imu_head.linear_acceleration_covariance))
      _x = self
      buff.write(_get_struct_3I().pack(_x.imu_body.header.seq, _x.imu_body.header.stamp.secs, _x.imu_body.header.stamp.nsecs))
      _x = self.imu_body.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_4d().pack(_x.imu_body.orientation.x, _x.imu_body.orientation.y, _x.imu_body.orientation.z, _x.imu_body.orientation.w))
      buff.write(_get_struct_9d().pack(*self.imu_body.orientation_covariance))
      _x = self
      buff.write(_get_struct_3d().pack(_x.imu_body.angular_velocity.x, _x.imu_body.angular_velocity.y, _x.imu_body.angular_velocity.z))
      buff.write(_get_struct_9d().pack(*self.imu_body.angular_velocity_covariance))
      _x = self
      buff.write(_get_struct_3d().pack(_x.imu_body.linear_acceleration.x, _x.imu_body.linear_acceleration.y, _x.imu_body.linear_acceleration.z))
      buff.write(_get_struct_9d().pack(*self.imu_body.linear_acceleration_covariance))
      _x = self
      buff.write(_get_struct_3I().pack(_x.kinematic_joints.header.seq, _x.kinematic_joints.header.stamp.secs, _x.kinematic_joints.header.stamp.nsecs))
      _x = self.kinematic_joints.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.kinematic_joints.name)
      buff.write(_struct_I.pack(length))
      for val1 in self.kinematic_joints.name:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.kinematic_joints.position)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.kinematic_joints.position))
      length = len(self.kinematic_joints.velocity)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.kinematic_joints.velocity))
      length = len(self.kinematic_joints.effort)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.kinematic_joints.effort))
      length = len(self.light.layout.dim)
      buff.write(_struct_I.pack(length))
      for val1 in self.light.layout.dim:
        _x = val1.label
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.size, _x.stride))
      buff.write(_get_struct_I().pack(self.light.layout.data_offset))
      length = len(self.light.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.pack(pattern, *self.light.data))
      _x = self
      buff.write(_get_struct_3I().pack(_x.odom.header.seq, _x.odom.header.stamp.secs, _x.odom.header.stamp.nsecs))
      _x = self.odom.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.odom.child_frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_7d().pack(_x.odom.pose.pose.position.x, _x.odom.pose.pose.position.y, _x.odom.pose.pose.position.z, _x.odom.pose.pose.orientation.x, _x.odom.pose.pose.orientation.y, _x.odom.pose.pose.orientation.z, _x.odom.pose.pose.orientation.w))
      buff.write(_get_struct_36d().pack(*self.odom.pose.covariance))
      _x = self
      buff.write(_get_struct_6d().pack(_x.odom.twist.twist.linear.x, _x.odom.twist.twist.linear.y, _x.odom.twist.twist.linear.z, _x.odom.twist.twist.angular.x, _x.odom.twist.twist.angular.y, _x.odom.twist.twist.angular.z))
      buff.write(_get_struct_36d().pack(*self.odom.twist.covariance))
      _x = self
      buff.write(_get_struct_3I().pack(_x.sonar.header.seq, _x.sonar.header.stamp.secs, _x.sonar.header.stamp.nsecs))
      _x = self.sonar.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_B4f().pack(_x.sonar.radiation_type, _x.sonar.field_of_view, _x.sonar.min_range, _x.sonar.max_range, _x.sonar.range))
      length = len(self.stream.layout.dim)
      buff.write(_struct_I.pack(length))
      for val1 in self.stream.layout.dim:
        _x = val1.label
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.size, _x.stride))
      buff.write(_get_struct_I().pack(self.stream.layout.data_offset))
      length = len(self.stream.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sH'%length
      buff.write(struct.pack(pattern, *self.stream.data))
      _x = self
      buff.write(_get_struct_2H().pack(_x.touch_body.data, _x.touch_head.data))
      length = len(self.wheel_speed_cmd.layout.dim)
      buff.write(_struct_I.pack(length))
      for val1 in self.wheel_speed_cmd.layout.dim:
        _x = val1.label
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.size, _x.stride))
      buff.write(_get_struct_I().pack(self.wheel_speed_cmd.layout.data_offset))
      length = len(self.wheel_speed_cmd.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.pack(pattern, *self.wheel_speed_cmd.data))
      length = len(self.wheel_speed_back_emf.layout.dim)
      buff.write(_struct_I.pack(length))
      for val1 in self.wheel_speed_back_emf.layout.dim:
        _x = val1.label
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.size, _x.stride))
      buff.write(_get_struct_I().pack(self.wheel_speed_back_emf.layout.data_offset))
      length = len(self.wheel_speed_back_emf.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.pack(pattern, *self.wheel_speed_back_emf.data))
      length = len(self.wheel_speed_opto.layout.dim)
      buff.write(_struct_I.pack(length))
      for val1 in self.wheel_speed_opto.layout.dim:
        _x = val1.label
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.size, _x.stride))
      buff.write(_get_struct_I().pack(self.wheel_speed_opto.layout.data_offset))
      length = len(self.wheel_speed_opto.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.pack(pattern, *self.wheel_speed_opto.data))
      length = len(self.wheel_effort_pwm.layout.dim)
      buff.write(_struct_I.pack(length))
      for val1 in self.wheel_effort_pwm.layout.dim:
        _x = val1.label
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.size, _x.stride))
      buff.write(_get_struct_I().pack(self.wheel_effort_pwm.layout.data_offset))
      length = len(self.wheel_effort_pwm.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(struct.pack(pattern, *self.wheel_effort_pwm.data))
      _x = self
      buff.write(_get_struct_3d().pack(_x.body_pose.x, _x.body_pose.y, _x.body_pose.theta))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.battery is None:
        self.battery = sensor_msgs.msg.BatteryState()
      if self.cliff is None:
        self.cliff = std_msgs.msg.Float32MultiArray()
      if self.dip is None:
        self.dip = std_msgs.msg.UInt16()
      if self.flags is None:
        self.flags = std_msgs.msg.UInt32()
      if self.imu_head is None:
        self.imu_head = sensor_msgs.msg.Imu()
      if self.imu_body is None:
        self.imu_body = sensor_msgs.msg.Imu()
      if self.kinematic_joints is None:
        self.kinematic_joints = sensor_msgs.msg.JointState()
      if self.light is None:
        self.light = std_msgs.msg.Float32MultiArray()
      if self.odom is None:
        self.odom = nav_msgs.msg.Odometry()
      if self.sonar is None:
        self.sonar = sensor_msgs.msg.Range()
      if self.stream is None:
        self.stream = std_msgs.msg.UInt16MultiArray()
      if self.touch_body is None:
        self.touch_body = std_msgs.msg.UInt16()
      if self.touch_head is None:
        self.touch_head = std_msgs.msg.UInt16()
      if self.wheel_speed_cmd is None:
        self.wheel_speed_cmd = std_msgs.msg.Float32MultiArray()
      if self.wheel_speed_back_emf is None:
        self.wheel_speed_back_emf = std_msgs.msg.Float32MultiArray()
      if self.wheel_speed_opto is None:
        self.wheel_speed_opto = std_msgs.msg.Float32MultiArray()
      if self.wheel_effort_pwm is None:
        self.wheel_effort_pwm = std_msgs.msg.Float32MultiArray()
      if self.body_pose is None:
        self.body_pose = geometry_msgs.msg.Pose2D()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 12
      (_x.battery.header.seq, _x.battery.header.stamp.secs, _x.battery.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.battery.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.battery.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 28
      (_x.battery.voltage, _x.battery.current, _x.battery.charge, _x.battery.capacity, _x.battery.design_capacity, _x.battery.percentage, _x.battery.power_supply_status, _x.battery.power_supply_health, _x.battery.power_supply_technology, _x.battery.present,) = _get_struct_6f4B().unpack(str[start:end])
      self.battery.present = bool(self.battery.present)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      end += struct.calcsize(pattern)
      self.battery.cell_voltage = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.battery.location = str[start:end].decode('utf-8')
      else:
        self.battery.location = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.battery.serial_number = str[start:end].decode('utf-8')
      else:
        self.battery.serial_number = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.cliff.layout.dim = []
      for i in range(0, length):
        val1 = std_msgs.msg.MultiArrayDimension()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.label = str[start:end].decode('utf-8')
        else:
          val1.label = str[start:end]
        _x = val1
        start = end
        end += 8
        (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
        self.cliff.layout.dim.append(val1)
      start = end
      end += 4
      (self.cliff.layout.data_offset,) = _get_struct_I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      end += struct.calcsize(pattern)
      self.cliff.data = struct.unpack(pattern, str[start:end])
      _x = self
      start = end
      end += 18
      (_x.dip.data, _x.flags.data, _x.imu_head.header.seq, _x.imu_head.header.stamp.secs, _x.imu_head.header.stamp.nsecs,) = _get_struct_H4I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.imu_head.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.imu_head.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 32
      (_x.imu_head.orientation.x, _x.imu_head.orientation.y, _x.imu_head.orientation.z, _x.imu_head.orientation.w,) = _get_struct_4d().unpack(str[start:end])
      start = end
      end += 72
      self.imu_head.orientation_covariance = _get_struct_9d().unpack(str[start:end])
      _x = self
      start = end
      end += 24
      (_x.imu_head.angular_velocity.x, _x.imu_head.angular_velocity.y, _x.imu_head.angular_velocity.z,) = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 72
      self.imu_head.angular_velocity_covariance = _get_struct_9d().unpack(str[start:end])
      _x = self
      start = end
      end += 24
      (_x.imu_head.linear_acceleration.x, _x.imu_head.linear_acceleration.y, _x.imu_head.linear_acceleration.z,) = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 72
      self.imu_head.linear_acceleration_covariance = _get_struct_9d().unpack(str[start:end])
      _x = self
      start = end
      end += 12
      (_x.imu_body.header.seq, _x.imu_body.header.stamp.secs, _x.imu_body.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.imu_body.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.imu_body.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 32
      (_x.imu_body.orientation.x, _x.imu_body.orientation.y, _x.imu_body.orientation.z, _x.imu_body.orientation.w,) = _get_struct_4d().unpack(str[start:end])
      start = end
      end += 72
      self.imu_body.orientation_covariance = _get_struct_9d().unpack(str[start:end])
      _x = self
      start = end
      end += 24
      (_x.imu_body.angular_velocity.x, _x.imu_body.angular_velocity.y, _x.imu_body.angular_velocity.z,) = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 72
      self.imu_body.angular_velocity_covariance = _get_struct_9d().unpack(str[start:end])
      _x = self
      start = end
      end += 24
      (_x.imu_body.linear_acceleration.x, _x.imu_body.linear_acceleration.y, _x.imu_body.linear_acceleration.z,) = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 72
      self.imu_body.linear_acceleration_covariance = _get_struct_9d().unpack(str[start:end])
      _x = self
      start = end
      end += 12
      (_x.kinematic_joints.header.seq, _x.kinematic_joints.header.stamp.secs, _x.kinematic_joints.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.kinematic_joints.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.kinematic_joints.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.kinematic_joints.name = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.kinematic_joints.name.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.kinematic_joints.position = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.kinematic_joints.velocity = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.kinematic_joints.effort = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.light.layout.dim = []
      for i in range(0, length):
        val1 = std_msgs.msg.MultiArrayDimension()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.label = str[start:end].decode('utf-8')
        else:
          val1.label = str[start:end]
        _x = val1
        start = end
        end += 8
        (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
        self.light.layout.dim.append(val1)
      start = end
      end += 4
      (self.light.layout.data_offset,) = _get_struct_I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      end += struct.calcsize(pattern)
      self.light.data = struct.unpack(pattern, str[start:end])
      _x = self
      start = end
      end += 12
      (_x.odom.header.seq, _x.odom.header.stamp.secs, _x.odom.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.odom.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.odom.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.odom.child_frame_id = str[start:end].decode('utf-8')
      else:
        self.odom.child_frame_id = str[start:end]
      _x = self
      start = end
      end += 56
      (_x.odom.pose.pose.position.x, _x.odom.pose.pose.position.y, _x.odom.pose.pose.position.z, _x.odom.pose.pose.orientation.x, _x.odom.pose.pose.orientation.y, _x.odom.pose.pose.orientation.z, _x.odom.pose.pose.orientation.w,) = _get_struct_7d().unpack(str[start:end])
      start = end
      end += 288
      self.odom.pose.covariance = _get_struct_36d().unpack(str[start:end])
      _x = self
      start = end
      end += 48
      (_x.odom.twist.twist.linear.x, _x.odom.twist.twist.linear.y, _x.odom.twist.twist.linear.z, _x.odom.twist.twist.angular.x, _x.odom.twist.twist.angular.y, _x.odom.twist.twist.angular.z,) = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 288
      self.odom.twist.covariance = _get_struct_36d().unpack(str[start:end])
      _x = self
      start = end
      end += 12
      (_x.sonar.header.seq, _x.sonar.header.stamp.secs, _x.sonar.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.sonar.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.sonar.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 17
      (_x.sonar.radiation_type, _x.sonar.field_of_view, _x.sonar.min_range, _x.sonar.max_range, _x.sonar.range,) = _get_struct_B4f().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.stream.layout.dim = []
      for i in range(0, length):
        val1 = std_msgs.msg.MultiArrayDimension()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.label = str[start:end].decode('utf-8')
        else:
          val1.label = str[start:end]
        _x = val1
        start = end
        end += 8
        (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
        self.stream.layout.dim.append(val1)
      start = end
      end += 4
      (self.stream.layout.data_offset,) = _get_struct_I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sH'%length
      start = end
      end += struct.calcsize(pattern)
      self.stream.data = struct.unpack(pattern, str[start:end])
      _x = self
      start = end
      end += 4
      (_x.touch_body.data, _x.touch_head.data,) = _get_struct_2H().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.wheel_speed_cmd.layout.dim = []
      for i in range(0, length):
        val1 = std_msgs.msg.MultiArrayDimension()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.label = str[start:end].decode('utf-8')
        else:
          val1.label = str[start:end]
        _x = val1
        start = end
        end += 8
        (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
        self.wheel_speed_cmd.layout.dim.append(val1)
      start = end
      end += 4
      (self.wheel_speed_cmd.layout.data_offset,) = _get_struct_I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      end += struct.calcsize(pattern)
      self.wheel_speed_cmd.data = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.wheel_speed_back_emf.layout.dim = []
      for i in range(0, length):
        val1 = std_msgs.msg.MultiArrayDimension()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.label = str[start:end].decode('utf-8')
        else:
          val1.label = str[start:end]
        _x = val1
        start = end
        end += 8
        (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
        self.wheel_speed_back_emf.layout.dim.append(val1)
      start = end
      end += 4
      (self.wheel_speed_back_emf.layout.data_offset,) = _get_struct_I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      end += struct.calcsize(pattern)
      self.wheel_speed_back_emf.data = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.wheel_speed_opto.layout.dim = []
      for i in range(0, length):
        val1 = std_msgs.msg.MultiArrayDimension()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.label = str[start:end].decode('utf-8')
        else:
          val1.label = str[start:end]
        _x = val1
        start = end
        end += 8
        (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
        self.wheel_speed_opto.layout.dim.append(val1)
      start = end
      end += 4
      (self.wheel_speed_opto.layout.data_offset,) = _get_struct_I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      end += struct.calcsize(pattern)
      self.wheel_speed_opto.data = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.wheel_effort_pwm.layout.dim = []
      for i in range(0, length):
        val1 = std_msgs.msg.MultiArrayDimension()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.label = str[start:end].decode('utf-8')
        else:
          val1.label = str[start:end]
        _x = val1
        start = end
        end += 8
        (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
        self.wheel_effort_pwm.layout.dim.append(val1)
      start = end
      end += 4
      (self.wheel_effort_pwm.layout.data_offset,) = _get_struct_I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      end += struct.calcsize(pattern)
      self.wheel_effort_pwm.data = struct.unpack(pattern, str[start:end])
      _x = self
      start = end
      end += 24
      (_x.body_pose.x, _x.body_pose.y, _x.body_pose.theta,) = _get_struct_3d().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_3I().pack(_x.battery.header.seq, _x.battery.header.stamp.secs, _x.battery.header.stamp.nsecs))
      _x = self.battery.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_6f4B().pack(_x.battery.voltage, _x.battery.current, _x.battery.charge, _x.battery.capacity, _x.battery.design_capacity, _x.battery.percentage, _x.battery.power_supply_status, _x.battery.power_supply_health, _x.battery.power_supply_technology, _x.battery.present))
      length = len(self.battery.cell_voltage)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.battery.cell_voltage.tostring())
      _x = self.battery.location
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.battery.serial_number
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.cliff.layout.dim)
      buff.write(_struct_I.pack(length))
      for val1 in self.cliff.layout.dim:
        _x = val1.label
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.size, _x.stride))
      buff.write(_get_struct_I().pack(self.cliff.layout.data_offset))
      length = len(self.cliff.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.cliff.data.tostring())
      _x = self
      buff.write(_get_struct_H4I().pack(_x.dip.data, _x.flags.data, _x.imu_head.header.seq, _x.imu_head.header.stamp.secs, _x.imu_head.header.stamp.nsecs))
      _x = self.imu_head.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_4d().pack(_x.imu_head.orientation.x, _x.imu_head.orientation.y, _x.imu_head.orientation.z, _x.imu_head.orientation.w))
      buff.write(self.imu_head.orientation_covariance.tostring())
      _x = self
      buff.write(_get_struct_3d().pack(_x.imu_head.angular_velocity.x, _x.imu_head.angular_velocity.y, _x.imu_head.angular_velocity.z))
      buff.write(self.imu_head.angular_velocity_covariance.tostring())
      _x = self
      buff.write(_get_struct_3d().pack(_x.imu_head.linear_acceleration.x, _x.imu_head.linear_acceleration.y, _x.imu_head.linear_acceleration.z))
      buff.write(self.imu_head.linear_acceleration_covariance.tostring())
      _x = self
      buff.write(_get_struct_3I().pack(_x.imu_body.header.seq, _x.imu_body.header.stamp.secs, _x.imu_body.header.stamp.nsecs))
      _x = self.imu_body.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_4d().pack(_x.imu_body.orientation.x, _x.imu_body.orientation.y, _x.imu_body.orientation.z, _x.imu_body.orientation.w))
      buff.write(self.imu_body.orientation_covariance.tostring())
      _x = self
      buff.write(_get_struct_3d().pack(_x.imu_body.angular_velocity.x, _x.imu_body.angular_velocity.y, _x.imu_body.angular_velocity.z))
      buff.write(self.imu_body.angular_velocity_covariance.tostring())
      _x = self
      buff.write(_get_struct_3d().pack(_x.imu_body.linear_acceleration.x, _x.imu_body.linear_acceleration.y, _x.imu_body.linear_acceleration.z))
      buff.write(self.imu_body.linear_acceleration_covariance.tostring())
      _x = self
      buff.write(_get_struct_3I().pack(_x.kinematic_joints.header.seq, _x.kinematic_joints.header.stamp.secs, _x.kinematic_joints.header.stamp.nsecs))
      _x = self.kinematic_joints.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      length = len(self.kinematic_joints.name)
      buff.write(_struct_I.pack(length))
      for val1 in self.kinematic_joints.name:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.pack('<I%ss'%length, length, val1))
      length = len(self.kinematic_joints.position)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.kinematic_joints.position.tostring())
      length = len(self.kinematic_joints.velocity)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.kinematic_joints.velocity.tostring())
      length = len(self.kinematic_joints.effort)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.kinematic_joints.effort.tostring())
      length = len(self.light.layout.dim)
      buff.write(_struct_I.pack(length))
      for val1 in self.light.layout.dim:
        _x = val1.label
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.size, _x.stride))
      buff.write(_get_struct_I().pack(self.light.layout.data_offset))
      length = len(self.light.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.light.data.tostring())
      _x = self
      buff.write(_get_struct_3I().pack(_x.odom.header.seq, _x.odom.header.stamp.secs, _x.odom.header.stamp.nsecs))
      _x = self.odom.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self.odom.child_frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_7d().pack(_x.odom.pose.pose.position.x, _x.odom.pose.pose.position.y, _x.odom.pose.pose.position.z, _x.odom.pose.pose.orientation.x, _x.odom.pose.pose.orientation.y, _x.odom.pose.pose.orientation.z, _x.odom.pose.pose.orientation.w))
      buff.write(self.odom.pose.covariance.tostring())
      _x = self
      buff.write(_get_struct_6d().pack(_x.odom.twist.twist.linear.x, _x.odom.twist.twist.linear.y, _x.odom.twist.twist.linear.z, _x.odom.twist.twist.angular.x, _x.odom.twist.twist.angular.y, _x.odom.twist.twist.angular.z))
      buff.write(self.odom.twist.covariance.tostring())
      _x = self
      buff.write(_get_struct_3I().pack(_x.sonar.header.seq, _x.sonar.header.stamp.secs, _x.sonar.header.stamp.nsecs))
      _x = self.sonar.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.pack('<I%ss'%length, length, _x))
      _x = self
      buff.write(_get_struct_B4f().pack(_x.sonar.radiation_type, _x.sonar.field_of_view, _x.sonar.min_range, _x.sonar.max_range, _x.sonar.range))
      length = len(self.stream.layout.dim)
      buff.write(_struct_I.pack(length))
      for val1 in self.stream.layout.dim:
        _x = val1.label
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.size, _x.stride))
      buff.write(_get_struct_I().pack(self.stream.layout.data_offset))
      length = len(self.stream.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sH'%length
      buff.write(self.stream.data.tostring())
      _x = self
      buff.write(_get_struct_2H().pack(_x.touch_body.data, _x.touch_head.data))
      length = len(self.wheel_speed_cmd.layout.dim)
      buff.write(_struct_I.pack(length))
      for val1 in self.wheel_speed_cmd.layout.dim:
        _x = val1.label
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.size, _x.stride))
      buff.write(_get_struct_I().pack(self.wheel_speed_cmd.layout.data_offset))
      length = len(self.wheel_speed_cmd.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.wheel_speed_cmd.data.tostring())
      length = len(self.wheel_speed_back_emf.layout.dim)
      buff.write(_struct_I.pack(length))
      for val1 in self.wheel_speed_back_emf.layout.dim:
        _x = val1.label
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.size, _x.stride))
      buff.write(_get_struct_I().pack(self.wheel_speed_back_emf.layout.data_offset))
      length = len(self.wheel_speed_back_emf.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.wheel_speed_back_emf.data.tostring())
      length = len(self.wheel_speed_opto.layout.dim)
      buff.write(_struct_I.pack(length))
      for val1 in self.wheel_speed_opto.layout.dim:
        _x = val1.label
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.size, _x.stride))
      buff.write(_get_struct_I().pack(self.wheel_speed_opto.layout.data_offset))
      length = len(self.wheel_speed_opto.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.wheel_speed_opto.data.tostring())
      length = len(self.wheel_effort_pwm.layout.dim)
      buff.write(_struct_I.pack(length))
      for val1 in self.wheel_effort_pwm.layout.dim:
        _x = val1.label
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.pack('<I%ss'%length, length, _x))
        _x = val1
        buff.write(_get_struct_2I().pack(_x.size, _x.stride))
      buff.write(_get_struct_I().pack(self.wheel_effort_pwm.layout.data_offset))
      length = len(self.wheel_effort_pwm.data)
      buff.write(_struct_I.pack(length))
      pattern = '<%sf'%length
      buff.write(self.wheel_effort_pwm.data.tostring())
      _x = self
      buff.write(_get_struct_3d().pack(_x.body_pose.x, _x.body_pose.y, _x.body_pose.theta))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.battery is None:
        self.battery = sensor_msgs.msg.BatteryState()
      if self.cliff is None:
        self.cliff = std_msgs.msg.Float32MultiArray()
      if self.dip is None:
        self.dip = std_msgs.msg.UInt16()
      if self.flags is None:
        self.flags = std_msgs.msg.UInt32()
      if self.imu_head is None:
        self.imu_head = sensor_msgs.msg.Imu()
      if self.imu_body is None:
        self.imu_body = sensor_msgs.msg.Imu()
      if self.kinematic_joints is None:
        self.kinematic_joints = sensor_msgs.msg.JointState()
      if self.light is None:
        self.light = std_msgs.msg.Float32MultiArray()
      if self.odom is None:
        self.odom = nav_msgs.msg.Odometry()
      if self.sonar is None:
        self.sonar = sensor_msgs.msg.Range()
      if self.stream is None:
        self.stream = std_msgs.msg.UInt16MultiArray()
      if self.touch_body is None:
        self.touch_body = std_msgs.msg.UInt16()
      if self.touch_head is None:
        self.touch_head = std_msgs.msg.UInt16()
      if self.wheel_speed_cmd is None:
        self.wheel_speed_cmd = std_msgs.msg.Float32MultiArray()
      if self.wheel_speed_back_emf is None:
        self.wheel_speed_back_emf = std_msgs.msg.Float32MultiArray()
      if self.wheel_speed_opto is None:
        self.wheel_speed_opto = std_msgs.msg.Float32MultiArray()
      if self.wheel_effort_pwm is None:
        self.wheel_effort_pwm = std_msgs.msg.Float32MultiArray()
      if self.body_pose is None:
        self.body_pose = geometry_msgs.msg.Pose2D()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 12
      (_x.battery.header.seq, _x.battery.header.stamp.secs, _x.battery.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.battery.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.battery.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 28
      (_x.battery.voltage, _x.battery.current, _x.battery.charge, _x.battery.capacity, _x.battery.design_capacity, _x.battery.percentage, _x.battery.power_supply_status, _x.battery.power_supply_health, _x.battery.power_supply_technology, _x.battery.present,) = _get_struct_6f4B().unpack(str[start:end])
      self.battery.present = bool(self.battery.present)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      end += struct.calcsize(pattern)
      self.battery.cell_voltage = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.battery.location = str[start:end].decode('utf-8')
      else:
        self.battery.location = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.battery.serial_number = str[start:end].decode('utf-8')
      else:
        self.battery.serial_number = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.cliff.layout.dim = []
      for i in range(0, length):
        val1 = std_msgs.msg.MultiArrayDimension()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.label = str[start:end].decode('utf-8')
        else:
          val1.label = str[start:end]
        _x = val1
        start = end
        end += 8
        (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
        self.cliff.layout.dim.append(val1)
      start = end
      end += 4
      (self.cliff.layout.data_offset,) = _get_struct_I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      end += struct.calcsize(pattern)
      self.cliff.data = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      _x = self
      start = end
      end += 18
      (_x.dip.data, _x.flags.data, _x.imu_head.header.seq, _x.imu_head.header.stamp.secs, _x.imu_head.header.stamp.nsecs,) = _get_struct_H4I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.imu_head.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.imu_head.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 32
      (_x.imu_head.orientation.x, _x.imu_head.orientation.y, _x.imu_head.orientation.z, _x.imu_head.orientation.w,) = _get_struct_4d().unpack(str[start:end])
      start = end
      end += 72
      self.imu_head.orientation_covariance = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=9)
      _x = self
      start = end
      end += 24
      (_x.imu_head.angular_velocity.x, _x.imu_head.angular_velocity.y, _x.imu_head.angular_velocity.z,) = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 72
      self.imu_head.angular_velocity_covariance = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=9)
      _x = self
      start = end
      end += 24
      (_x.imu_head.linear_acceleration.x, _x.imu_head.linear_acceleration.y, _x.imu_head.linear_acceleration.z,) = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 72
      self.imu_head.linear_acceleration_covariance = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=9)
      _x = self
      start = end
      end += 12
      (_x.imu_body.header.seq, _x.imu_body.header.stamp.secs, _x.imu_body.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.imu_body.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.imu_body.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 32
      (_x.imu_body.orientation.x, _x.imu_body.orientation.y, _x.imu_body.orientation.z, _x.imu_body.orientation.w,) = _get_struct_4d().unpack(str[start:end])
      start = end
      end += 72
      self.imu_body.orientation_covariance = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=9)
      _x = self
      start = end
      end += 24
      (_x.imu_body.angular_velocity.x, _x.imu_body.angular_velocity.y, _x.imu_body.angular_velocity.z,) = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 72
      self.imu_body.angular_velocity_covariance = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=9)
      _x = self
      start = end
      end += 24
      (_x.imu_body.linear_acceleration.x, _x.imu_body.linear_acceleration.y, _x.imu_body.linear_acceleration.z,) = _get_struct_3d().unpack(str[start:end])
      start = end
      end += 72
      self.imu_body.linear_acceleration_covariance = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=9)
      _x = self
      start = end
      end += 12
      (_x.kinematic_joints.header.seq, _x.kinematic_joints.header.stamp.secs, _x.kinematic_joints.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.kinematic_joints.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.kinematic_joints.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.kinematic_joints.name = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8')
        else:
          val1 = str[start:end]
        self.kinematic_joints.name.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.kinematic_joints.position = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.kinematic_joints.velocity = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.kinematic_joints.effort = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.light.layout.dim = []
      for i in range(0, length):
        val1 = std_msgs.msg.MultiArrayDimension()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.label = str[start:end].decode('utf-8')
        else:
          val1.label = str[start:end]
        _x = val1
        start = end
        end += 8
        (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
        self.light.layout.dim.append(val1)
      start = end
      end += 4
      (self.light.layout.data_offset,) = _get_struct_I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      end += struct.calcsize(pattern)
      self.light.data = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      _x = self
      start = end
      end += 12
      (_x.odom.header.seq, _x.odom.header.stamp.secs, _x.odom.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.odom.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.odom.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.odom.child_frame_id = str[start:end].decode('utf-8')
      else:
        self.odom.child_frame_id = str[start:end]
      _x = self
      start = end
      end += 56
      (_x.odom.pose.pose.position.x, _x.odom.pose.pose.position.y, _x.odom.pose.pose.position.z, _x.odom.pose.pose.orientation.x, _x.odom.pose.pose.orientation.y, _x.odom.pose.pose.orientation.z, _x.odom.pose.pose.orientation.w,) = _get_struct_7d().unpack(str[start:end])
      start = end
      end += 288
      self.odom.pose.covariance = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=36)
      _x = self
      start = end
      end += 48
      (_x.odom.twist.twist.linear.x, _x.odom.twist.twist.linear.y, _x.odom.twist.twist.linear.z, _x.odom.twist.twist.angular.x, _x.odom.twist.twist.angular.y, _x.odom.twist.twist.angular.z,) = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 288
      self.odom.twist.covariance = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=36)
      _x = self
      start = end
      end += 12
      (_x.sonar.header.seq, _x.sonar.header.stamp.secs, _x.sonar.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.sonar.header.frame_id = str[start:end].decode('utf-8')
      else:
        self.sonar.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 17
      (_x.sonar.radiation_type, _x.sonar.field_of_view, _x.sonar.min_range, _x.sonar.max_range, _x.sonar.range,) = _get_struct_B4f().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.stream.layout.dim = []
      for i in range(0, length):
        val1 = std_msgs.msg.MultiArrayDimension()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.label = str[start:end].decode('utf-8')
        else:
          val1.label = str[start:end]
        _x = val1
        start = end
        end += 8
        (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
        self.stream.layout.dim.append(val1)
      start = end
      end += 4
      (self.stream.layout.data_offset,) = _get_struct_I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sH'%length
      start = end
      end += struct.calcsize(pattern)
      self.stream.data = numpy.frombuffer(str[start:end], dtype=numpy.uint16, count=length)
      _x = self
      start = end
      end += 4
      (_x.touch_body.data, _x.touch_head.data,) = _get_struct_2H().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.wheel_speed_cmd.layout.dim = []
      for i in range(0, length):
        val1 = std_msgs.msg.MultiArrayDimension()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.label = str[start:end].decode('utf-8')
        else:
          val1.label = str[start:end]
        _x = val1
        start = end
        end += 8
        (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
        self.wheel_speed_cmd.layout.dim.append(val1)
      start = end
      end += 4
      (self.wheel_speed_cmd.layout.data_offset,) = _get_struct_I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      end += struct.calcsize(pattern)
      self.wheel_speed_cmd.data = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.wheel_speed_back_emf.layout.dim = []
      for i in range(0, length):
        val1 = std_msgs.msg.MultiArrayDimension()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.label = str[start:end].decode('utf-8')
        else:
          val1.label = str[start:end]
        _x = val1
        start = end
        end += 8
        (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
        self.wheel_speed_back_emf.layout.dim.append(val1)
      start = end
      end += 4
      (self.wheel_speed_back_emf.layout.data_offset,) = _get_struct_I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      end += struct.calcsize(pattern)
      self.wheel_speed_back_emf.data = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.wheel_speed_opto.layout.dim = []
      for i in range(0, length):
        val1 = std_msgs.msg.MultiArrayDimension()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.label = str[start:end].decode('utf-8')
        else:
          val1.label = str[start:end]
        _x = val1
        start = end
        end += 8
        (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
        self.wheel_speed_opto.layout.dim.append(val1)
      start = end
      end += 4
      (self.wheel_speed_opto.layout.data_offset,) = _get_struct_I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      end += struct.calcsize(pattern)
      self.wheel_speed_opto.data = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.wheel_effort_pwm.layout.dim = []
      for i in range(0, length):
        val1 = std_msgs.msg.MultiArrayDimension()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.label = str[start:end].decode('utf-8')
        else:
          val1.label = str[start:end]
        _x = val1
        start = end
        end += 8
        (_x.size, _x.stride,) = _get_struct_2I().unpack(str[start:end])
        self.wheel_effort_pwm.layout.dim.append(val1)
      start = end
      end += 4
      (self.wheel_effort_pwm.layout.data_offset,) = _get_struct_I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sf'%length
      start = end
      end += struct.calcsize(pattern)
      self.wheel_effort_pwm.data = numpy.frombuffer(str[start:end], dtype=numpy.float32, count=length)
      _x = self
      start = end
      end += 24
      (_x.body_pose.x, _x.body_pose.y, _x.body_pose.theta,) = _get_struct_3d().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_7d = None
def _get_struct_7d():
    global _struct_7d
    if _struct_7d is None:
        _struct_7d = struct.Struct("<7d")
    return _struct_7d
_struct_6d = None
def _get_struct_6d():
    global _struct_6d
    if _struct_6d is None:
        _struct_6d = struct.Struct("<6d")
    return _struct_6d
_struct_36d = None
def _get_struct_36d():
    global _struct_36d
    if _struct_36d is None:
        _struct_36d = struct.Struct("<36d")
    return _struct_36d
_struct_9d = None
def _get_struct_9d():
    global _struct_9d
    if _struct_9d is None:
        _struct_9d = struct.Struct("<9d")
    return _struct_9d
_struct_H4I = None
def _get_struct_H4I():
    global _struct_H4I
    if _struct_H4I is None:
        _struct_H4I = struct.Struct("<H4I")
    return _struct_H4I
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_B4f = None
def _get_struct_B4f():
    global _struct_B4f
    if _struct_B4f is None:
        _struct_B4f = struct.Struct("<B4f")
    return _struct_B4f
_struct_6f4B = None
def _get_struct_6f4B():
    global _struct_6f4B
    if _struct_6f4B is None:
        _struct_6f4B = struct.Struct("<6f4B")
    return _struct_6f4B
_struct_4d = None
def _get_struct_4d():
    global _struct_4d
    if _struct_4d is None:
        _struct_4d = struct.Struct("<4d")
    return _struct_4d
_struct_2H = None
def _get_struct_2H():
    global _struct_2H
    if _struct_2H is None:
        _struct_2H = struct.Struct("<2H")
    return _struct_2H
_struct_2I = None
def _get_struct_2I():
    global _struct_2I
    if _struct_2I is None:
        _struct_2I = struct.Struct("<2I")
    return _struct_2I
_struct_3d = None
def _get_struct_3d():
    global _struct_3d
    if _struct_3d is None:
        _struct_3d = struct.Struct("<3d")
    return _struct_3d
